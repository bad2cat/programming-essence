### 建造者模式

#### 什么时建造者模式

建造者模式就是为了解决复杂对象初始化的问题，允许使用相同的创建代码生成不同类型和形式的对象

#### 为什么要用建造者模式

使用创建者模式就是为了解决繁杂的初始化对象的逻辑，比如：现在要创建一个 House 对象，首先需要创建 wall，然后再封顶，之后还会有窗户，门，以及其他的一些基础设施；除了上面的这些，可能还需要花园，泳池等配套设施；现在有两种方法来实现：

1. 创建一个类，将所有的所有的这些属性全部到包含到这个类当中，这样就能够实现对所有参数的控制；

   但是这样就会有一个问题，每个 House 对象的属性都不相同：

   - 如果只有一个构造函数，那么这个构造函数的参数列表会很长，并且有很多的参数在构建时是用不到的，这样会很出现构造对象是很复杂
   - 如果使用构造函数的重载，就会使得代码看起来不是很优雅

2. 创建一个 House 基类，包含一些基本的属性；然后，其他的设施，每种都成为一个子类，比如：花园成为 Garden 类，然后用 House 将这些子类组合在一起；但这会添加很多的子类，而且添加一个参数会使整个结构变的很复杂

#### 建造者模式的原理

建造者模式就是把构造对象的代码从产品类中抽取出来，放到一个名为建造者的独立的对象当中；将构造对象过程划分为多个步骤，比如：创建 wall，创建 proof，等等；

然后通过调用这些步骤中的一些来形成一个产品对象，在这的重点就是不需要调用所有的步骤，只需要调用那些匹配的步骤就好了

如果有不同的产品类型，比如：构造小木屋和构造碉堡；那么就可以添加两个不同创建者，然后在创建过程中使用这些创建者来生成不同类型的对象

比如：现在要创建一个小木屋和一个碉堡，那么首先要定义个通用的 Builder 接口，包含创建这两个 House 的所有步骤，然后再添加一个 WoodHouseBuilder 和GoldHouseBuilder 各自实现自己的逻辑；之后客户端只需要调用通用接口中的步骤就可以获取到自己想要创建的对象了

##### 主管

上面的过程中创建一个产品对象需要客户端熟悉创建产品的各个步骤，然后逐一的调用才能获取的到；现在对创建一个产品的步骤再一次进行封装，将其封装到一个主管类当中；也就是说，主管类定义了生成一个产品所需步骤的顺序，而具体每个步骤的实现还是在各个具体的创建者当中

这样对于客户端来说就隐藏了构建一个产品对象的所有细节，只需要调用主管类的`makeWoodHouse`或者`makeXXX`方法，即可生成具体的产品对象

![生成器设计模式结构](https://refactoringguru.cn/images/patterns/diagrams/builder/structure.png)

#### 建造者模式的的使用场景

建造者模式的出现是为了解决创建复杂对象的问题，比如：对象有很多的构造参数或者对象组合了很多的其他对象；

建造者模式提取了对象构建的参数为一些列的步骤，然后通过这些步骤来构建出一个特定的对象

建造者模式可以创建不同类型和不同形式的对象，通过使用同一种构建方式

建造者模式会隐藏构建对象的细节，对于客户端来说只需要知道简单的擦做即可

#### 建造者模式的实现方式

1. 清晰的定义通用步骤，确保它们可以创建所有形式的产品（不同类型的产品，需要不同的创建者）

2. 在 Builder 接口中声明这些步骤

3. 为各个形式的产品创建具体的创建者类型，如：HouseBuilder，并且实现这些步骤

   注：不要忘了添加获取创建结果对象的方法，因为不能 BaseBuilder 中声明该方法的返回类型，因为不同的生成器构造的产品可能没有公共的接口，因此不知道该方法返回的具体类型；但是如果是在单一类的层次中，就可以安全的在基本接口中添加获取对象的方法

4. 考虑是否添加主管类，如果想对客户端隐藏实现的细节，那么就可以封装生成各个产品的步骤

5. 客户端创建创建者对象和主管对象，将创建者对象传递到主管对象，然后调用主管类对象的方法生成指定的产品

#### 建造者模式的优缺点

1. 单一职责原则，可以将复杂构造代码从产品的业务逻辑当中分离出来
2. 生成不同形式的产品时，可以复用相同的创建代码
3. 因为增加了很多的类，所以代码的复杂度也会随之增加

参考链接：https://refactoringguru.cn/design-patterns/builder