### 建造者模式

#### 建造者模式

建造者模式是创建对象的一种机制，能够提升已有代码的灵活性和可复用性

#### 为什么要用建造者模式

建造者模式是为了解决复杂对象创建的问题；比如：现在要创建一个 House 对象，首先需要建墙，然后再封顶，之后还会有窗户，门，以及其他的一些基础设施；除了上面的这些，可能还需要花园，泳池等配套设施；现在有两种方法来实现：

1. 创建一个类，将所有这些属性全部到包含到这个类当中，这样就能够实现对所有参数的控制；

   但是这样就会有一个问题，每个 House 对象的属性都不相同：

   - 如果只有一个构造函数，那么这个构造函数的参数列表会很长，并且有很多的参数在构建时是用不到的，这样就会导致参数的冗余
   - 如果使用构造函数的重载，那么就需要列出很多中不同参数组合的构造函数，那就会有一个很长的构造函数的列表，并且如果新加参数时，还需要不断的进行调整

2. 创建一个 House 基类，包含一些基本的属性；其他的每种基础设施都添加为一个子类，比如：花园成为 Garden 类，游泳池为 Pool 类，然后用 House 将这些子类组合在一起；但这会添加很多的子类，而且添加一个参数会使整个结构变的很复杂

上面的这两种方式，虽然能够直接创建一个对象，但是不够灵活；如果新增一个参数或者是类就需要改动所有引用到的代码，而且当对象越来越大时，维护这个类就会变的很困难

#### 建造者模式的原理

建造者模式就是把构造对象的代码从产品类中抽取出来，放到一个名为建造者的独立的对象当中；将构造对象过程划分为多个步骤，比如：创建 wall，创建 pool，等等；

通过调用其中相关的步骤形成一个产品对象，在这的重点就是不需要调用所有的步骤，只需要调用那些匹配的步骤就好了

如果有不同的产品类型，那么就可以添加两个不同类型的建造者，然后分别调用对应的建造者中的步骤来形成指定的产品对象；比如：现在要创建一个小木屋和一个碉堡，那么首先要定义个通用的 Builder 接口，包含创建这两个 House 的所有步骤，然后再添加一个 WoodHouseBuilder 和GoldHouseBuilder 各自实现自己的逻辑；之后客户端只需要调用通用接口中的步骤就可以获取到自己想要创建的对象了

##### 主管

上面的过程中创建一个产品对象需要客户端熟悉创建产品的各个步骤，然后逐一的调用才能获取的到；现在对创建一个产品的步骤进行封装，将其封装到一个主管类当中；也就是说，主管类定义了生成一个产品所需步骤的顺序，而具体每个步骤的实现还是在各个具体的建造者当中

这样对于客户端来说就隐藏了构建一个产品对象的所有细节，只需要调用主管类的`makeWoodHouse`或者`makeXXX`方法，即可生成具体的产品对象

![生成器设计模式结构](https://refactoringguru.cn/images/patterns/diagrams/builder/structure.png)

#### 建造者模式的的使用场景

建造者模式的出现是为了解决创建复杂对象的问题，比如：对象有很多的构造参数或者对象组合了很多的其他对象；

建造者模式提取了对象构建的参数为一些列的步骤，然后通过这些步骤来构建出一个特定的对象

建造者模式可以创建不同类型和不同形式的对象，通过使用同一种构建方式

建造者模式会隐藏构建对象的细节，对于客户端来说只需要知道简单的擦做即可

#### 建造者模式的实现方式

1. 清晰的定义通用步骤，确保它们可以创建所有形式的产品（不同类型的产品，需要不同的建造者）

2. 在 建造者接口中声明这些通用的步骤

3. 为各个形式的产品创建具体的建造者类型，如：HouseBuilder，并且实现这些步骤

   注：不要忘了添加获取创建结果对象的方法，因为不能在 BaseBuilder 中声明该方法的返回类型，不同的生成器构造的产品可能没有公共的接口，因此不知道该方法返回的具体类型；但是如果是在单一类的层次中，就可以安全的在基本接口中添加获取对象的方法

4. 考虑是否添加主管类，如果想对客户端隐藏实现的细节，那么就可以封装生成各个产品的步骤

5. 客户端创建建造者对象和主管对象，将建造者对象传递到主管对象，然后调用主管类对象的方法生成指定的产品

#### 建造者模式的优缺点

1. 单一职责原则，可以将复杂构造代码从产品的业务逻辑当中分离出来
2. 生成不同形式的产品时，可以复用相同的创建代码
3. 因为增加了很多的类，所以代码的复杂度也会随之增加

参考链接：https://refactoringguru.cn/design-patterns/builder